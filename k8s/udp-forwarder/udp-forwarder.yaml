# UDP Forwarder - receives UDP inside cluster and forwards to host
# Uses hostNetwork to directly access the host's network stack
apiVersion: v1
kind: Pod
metadata:
  name: udp-forwarder
  labels:
    app: udp-forwarder
spec:
  hostNetwork: true # Using host's network as can send UDP to host.docker.internal
  dnsPolicy: ClusterFirstWithHostNet
  containers:
    - name: forwarder
      image: python:3.11-slim
      command:
        - python3
        - -c
        - |
          import socket
          import os
          import sys
          from datetime import datetime

          LISTEN_PORT = int(os.environ.get('LISTEN_PORT', '5000'))
          TARGET_HOST = os.environ.get('TARGET_HOST', 'host.docker.internal')
          TARGET_PORT = int(os.environ.get('TARGET_PORT', '5002'))

          print(f"[{datetime.now().isoformat()}] UDP Forwarder starting...", flush=True)
          print(f"[{datetime.now().isoformat()}] Listen: 0.0.0.0:{LISTEN_PORT}", flush=True)
          print(f"[{datetime.now().isoformat()}] Forward to: {TARGET_HOST}:{TARGET_PORT}", flush=True)

          # Receiving socket
          recv_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
          recv_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
          recv_sock.bind(('0.0.0.0', LISTEN_PORT))

          # Sending socket
          send_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

          # Resolve target address
          try:
              target_ip = socket.gethostbyname(TARGET_HOST)
              print(f"[{datetime.now().isoformat()}] Resolved {TARGET_HOST} -> {target_ip}", flush=True)
          except socket.gaierror as e:
              print(f"[{datetime.now().isoformat()}] WARNING: Could not resolve {TARGET_HOST}: {e}", flush=True)
              target_ip = TARGET_HOST

          target_addr = (target_ip, TARGET_PORT)

          packet_count = 0
          forward_count = 0
          error_count = 0

          print(f"[{datetime.now().isoformat()}] Ready to forward UDP packets", flush=True)

          try:
              while True:
                  data, addr = recv_sock.recvfrom(4096)
                  packet_count += 1

                  try:
                      send_sock.sendto(data, target_addr)
                      forward_count += 1
                  except Exception as e:
                      error_count += 1
                      if error_count <= 10:
                          print(f"[{datetime.now().isoformat()}] Forward error: {e}", flush=True)

                  if packet_count <= 10 or packet_count % 1000 == 0:
                      print(f"[{datetime.now().isoformat()}] Packets: recv={packet_count} fwd={forward_count} err={error_count}", flush=True)
          except KeyboardInterrupt:
              print(f"[{datetime.now().isoformat()}] Shutting down. Total: recv={packet_count} fwd={forward_count} err={error_count}", flush=True)
      env:
        - name: LISTEN_PORT
          value: "5000"
        - name: TARGET_HOST
          value: "host.docker.internal" # Docker host (my machine)
        - name: TARGET_PORT
          value: "5002" # Port on my machine (avoiding 5000 as it's blocked by AirPlay)
      resources:
        requests:
          memory: "64Mi"
          cpu: "100m"
        limits:
          memory: "128Mi"
          cpu: "500m"
---
# Service for orchestrator pods to send to
apiVersion: v1
kind: Service
metadata:
  name: udp-forwarder
  labels:
    app: udp-forwarder
spec:
  type: ClusterIP
  ports:
    - port: 5000
      targetPort: 5000
      protocol: UDP
      name: udp
  selector:
    app: udp-forwarder
